# jvm问题总结

>线上GC频繁，怎么定位问题
>
>dump内存 2.看各代使用频率 3.可以使用 看看到底哪些对象存储的多 3.看接口具体代码
>
>为什么要有新生代和老年代  对象什么时候进入老年代
>
>什么时候发现 `stackOverFlowError`
>
>`OOM`
>
>============================================================
>
>美团追魂七连问
>
>>1.解释一下对象的创建过程（半初始化）  https://blog.csdn.net/justloveyou_/article/details/72466416   这边博客
>
>>2.对象在内存中的存储布局
>
>>3.对象头具体包括什么
>
>>4.对象怎么定位
>
>>5.对象怎么分配
>
>===========================================================
>
>1. JVM 内存模型(概述) 内存分配怎么分配的 将堆，栈，引用计数器，方法区，本地方法区放些什么
>2. 堆中内存分配比例?
>3. 方法区的大小怎么设置?
>4. 栈大小怎么设置?
>5. 重载和重写在 JVM 层面是怎么鉴别的?
>6. JVM当中的方法内联?
>7. 你对方法区/元空间的理解?
>8. 堆中内存的分配?
>9. 魔数是什么?
>10. 讲讲JVM中的堆的分区和作用
>11. jvm中，直接内存是什么
>12. 你可以说一下什么是中断吗
>13. JVM这块了解多少？从内存划分，每个部分详细说一下，再到gc，最后问了解zgc吗？说说看？







# ==-------------------------------------------------------------------------类加载==

# 类加载概念

## 类加载器子系统作用

><img src="https://segmentfault.com/img/remote/1460000027081937/view" alt="preview" style="zoom:50%;" />
>
>JVM被分为三个主要的子系统：
>
>类加载器子系统   运行时数据区  执行引擎
>
>类加载子系统作用：
>
>1. 类加载子系统负责从文件系统或者网络中加载`class`文件，`class`文件在文件开有特定的文件标识（`0xCAFEBABE`）。俗称魔术
>2. 类加载器（`Class Loader`）只负责`class`文件的加载，至于它是否可以运行，则由执行引擎（`Execution Engine`）决定。
>3. 加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放**运行时常量池信息**，可能还包括字符串字面量和数字常量（这部分常量信息是`Class`文件中常量池部分的内存映射）。
>4. `Class`对象是存放在堆区的。



## 类的加载过程

>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（`Loading`）、验证（`Verification`）、准备（`Preparation`）、解析（`Resolution`）、初始化（`Initialization`）、使用（`Using`）和卸载（`Unloading`）七个阶段，其中验证、准备、解析三个部分统称为连接（`Linking`）。完整的流程图如下所示：
>
><img src="https://segmentfault.com/img/remote/1460000027081941/view" alt="preview" style="zoom:50%;" />
>
>加载阶段：
>
>加载`Loading`   阶段是整个类加载`Class Loading`过程中的一个阶段，`JVM`需要完成三件事：
>
>- 通过一个类的全限定名获取定义此类的二进制字节流。
>- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。`JDK8 class`对象是存放在堆区当中，类的元数据存放在方法区（元空间）元数据不等于类的`class`对象！`class`对象是加载的最终产品 ，类的方法代码、变量名、方法名、返回权限、返回值等都在方法区(元空间)  类信息放在方法区，对象放在堆上。
>- 在内存中生成一个代表这个类的`java.lang.Class`对象，作为方法区这个类的各种数据的访问入口。
>
>--------------
>
>--------------
>
>链接阶段：
>
>1. 验证阶段：目的在于确保`Class`文件的**字节流**中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。                                   主要包括四种验证：文件格式验证（魔术、版本号），元数据验证(是否有父类、抽象类方法实现没)，字节码验证，符号引用验证。
>
>2. 准备阶段：准备阶段正式为类中定义的变量--static静态变量也是类变量    分配内存并设置类变量初始值的阶段. 进行内存的分配仅包括`static`类变量 而不包括实例变量，实例变量将在对象实例化后随着对象一起分配再`Java`堆中，其次初始值通常情况下为数据类型的0值。例如：
>     `public static int value=1;`
>     变量`value`准备阶段后的初始值为`0`，而把`value`赋值为`1`的动作要等到类得初始化阶段才会执行
>
>`public static final int value=1`
>编译时`javac`将会把`value`生成`ConstValue`属性，在准备阶段 虚拟机就会把`value`值赋值为`1`
>
>
>
>3. 解析
>
>解析阶段时`java`虚拟机将常量池内的符号引用替换成直接引用的过程
>
>    	1.类或接口解析       符号引用通过全类名解析
>    2.字段解析 			字段所属于类或者方法的符号引用
>    3.方法解析 			接口方法解析
>
>------------
>
>--------------
>
>初始化：
>
>1. 就是执行类构造器<clinit>方法的过程，`static`变量或者静态代码块合并的赋值  并且是按照顺序执行的
>
>2. <clinit>类构造器 不需要显示调用父类构造器 java虚拟机会保证子类<clinit>方法执行前，父类<clinit>方法执行完毕 第一个执行`Object`
>3. <clinit> 类构造器但是不同于构造器    构造器是虚拟机视角下的<init>方法
>4. 虚拟机会保证一个类的类构造器<clinit>()在多线程环境中被正确的加锁、同步
>
>```java
>public class var{					类变量static  在JDK1.7存在方法区  JDK1.8存在堆中的  实例变量==成员变量 类变量=静态变量
>	private static final int a=1;   随 Class对象分配在堆中  准备阶段就已经完成赋值
>	private static int b=2;			随 Class对象分配在堆中  类变量 --->准备阶段赋予数据类型的0值  初始化阶段才会根据代码赋值  随着类一起消失 	
>	private int c=3;				随着java对象分配在堆中  实例变量--->实例变量将在对象实例化后随着对象一起分配在java堆中   随着对象一起消失
>	public void method(){
>		int d=4;					在栈中 随方法共存亡 必须赋值才能使用		
>	}
>}               
>```
>
>-------------
>
>--------------
>
>#### 什么时候会触发类的初始化
>
>1. 使用new关键字实例化对象的时候、读取或设置一个类的静态字段的时候、调用一个类的静态方法的时候；
>2. 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则要先触发其初始化；
>3. 当初始化一个类的时候，如果发现其父类还没有被初始化，则要先初始化其父类；** 这句话有待研究**
>4. 当虚拟机启动时，用户需要指定一个执行的主类（包含main方法的那个类），则虚拟机会优先初始化这个主类；
>5. 在JDK1.7以后，动态语言支持的时候，如果一个java.lang.invoke.MethodHandle实例最后的结果是要执行第1种情况的操作，则也要进行初始化。



## 类加载器

>1. `Bootstrap ClassLoader `最顶层的根加载类，主要加载核心类库，`Bootstrap ClassLoader`是由`C/C++`编写的，它本身是虚拟机的一部分，所以它并不是一个`JAVA`类.
>2. `Extention ClassLoader` 扩展的类加载器，加载目录`%JRE_HOME%\lib\ext`目录下的`jar`包和`class`文件。
>3. `Appclass Loader`             也称为`SystemAppClass`系统类加载器  加载当前应用的`classpath`的所有类。
>4. `User ClassLoader`           用户自定义类加载器
>
>------------
>
>为什么要自定义类加载器：
>
>1. 隔离加载类
>2. 修改类加载的方式
>3. 扩展加载源
>4. 防止源码泄露



## 线程类加载器

>![image-20210525213723423](C:\Users\whig\AppData\Roaming\Typora\typora-user-images\image-20210525213723423.png)
>
>这个时候，线程上下文类加载器`（Thread Context ClassLoader）`很好地解决了这个问题。`Thread`类中有`getContextClassLoader()`和`setContextClassLoader(ClassLoader cl)`方法用来获取和设置上下文类加载器，如果没有`setContextClassLoader(ClassLoader cl)`方法通过设置类加载器，那么线程将继承父线程的上下文类加载器，如果在应用程序的全局范围内都没有设置的话，那么这个上下文类加载器默认就是应用程序类加载器`（Application ClassLoader）`，换句话说`Java`默认的线程上下文类加载器就是应用程序类加载器`(AppClassLoader)`。通过线程上下文来加载第三方库`jndi`实现，而不依赖于双亲委派。大部分`Java Application`服务器`(jboss, tomcat..)`也是采用`contextClassLoader`来处理`web`服务（所以理解线程上下文类加载器，更能让我们理解`Tomcat`等服务器的实现原理、工作方式）。



## 双亲委派机制

>![img](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMjExMTM1MDU0ODI1?x-oss-process=image/format,png)
>
>双亲委派模型的工作过程：
>
>如果一个类加载器收到一个类加载的请求，首先不会自己去尝试加载这个类，`AppClassLoader`会查找资源，先看看缓存是否有，缓存有从缓存中获取，否则委托给父加载器`Extention ClassLoader`扩展的类加载器，看看是否有缓存。没有就就把这个请求委托给启动类加载器。由`Bootstrap ClassLoader`出面，它首先查找缓存，如果没有找到的话，就去找自己的规定的路径下，也就是`sun.mic.boot.class`下面的路径。`Bootstrap ClassLoader`如果没有查找成功，则`ExtClassLoader`自己在`java.ext.dirs`路径中去查找，查找成功就返回，查找不成功，再向下让子加载器找，`ExtClassLoader`查找不成功，`AppClassLoader`就自己查找，在`java.class.path`路径下查找。找到就返回。如果没有找到就让子类找，如果没有子类会怎么样？抛出各种异常。
>
>双亲委派机制源码--->`ClassLoader.loadClass()方法当中 `
>
>-------------
>
>------------



# 面试类加载

## 为什么有双亲委派?一定要遵循双亲委派么?

>优势：
>
>比如一个定义在`java.lang`包下的类，因为它被存放在`rt.jar`之中，所以在被加载过程汇总，会被一直委托到`Bootstrap ClassLoader`，最终由`Bootstrap ClassLoader`所加载。
>
>而一个用户自定义的类，他也会被一直委托到`Bootstrap ClassLoader`，但是因为`Bootstrap ClassLoader`不负责加载该类，那么会在由`Extention ClassLoader`尝试加载，而`Extention ClassLoader`也不负责这个类的加载，最终才会被`Application ClassLoader`加载。
>
>1. 避免类的重复加载
>2. 安全因素：防止核心API被随意篡改   (`当包名为java.lang`这种会报出不安全异常)
>
>劣势：
>
>通过双亲委派机制的原理可以得出一下结论：由于`BootstrapClassloader`是顶级类加载器，`BootstrapClassloader`无法委派`AppClassLoader`来加载类，也就是说`BootstrapClassloader`中加载的类中无法使用由`AppClassLoader`加载的类。可能绝大部分情况这个不算是问题，因为`BootstrapClassloader`加载的都是基础类，供`AppClassLoader`加载的类调用的类。但是万事万物都不是绝对的比如经典的`JAVA SPI`机制。



## 你觉得双亲委派这个名字有没有什么问题?

>双亲委派这个名字是很容易让人误会的，因为并不能帮助人理解后面的加载过程，反而让人感觉晕。双亲委派的原文是`parents delegate`。`parents`在英文中是“父母”、“双亲”的意思，但其实表达的是“父母这一辈”的人的意思。实际上这个模型中，只是表达“父母这一辈”的`class loader`而已，所以所谓的双亲委派就是：
>
>1. 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。
>
>2. 每一个层次的类加载器都是如此。因此，所有的加载请求最终都应该传送到顶层的启动类加载器中。
>
>3. 只有当父加载器反馈自己无法完成这个加载请求时（搜索范围中没有找到所需的类），子加载器才会尝试自己去加载。



## 打破双亲委派的例子,举个例子?怎么打破?

>因为他的双亲委派过程都是在`loadClass`方法中实现的，那么**想要破坏这种机制，那么就自定义一个类加载器，重写其中的`loadClass`方法，使其不进行双亲委派即可。**
>
>`loadClass（）、findClass（）、defineClass（）`区别
>
>`ClassLoader`中和类加载有关的方法有很多，前面提到了`loadClass`，除此之外，还有`findClass和defineClass`等，那么这几个方法有什么区别呢？
>
>- `loadClass():`	就是主要进行类加载的方法，默认的双亲委派机制就实现在这个方法中。
>- `findClass(): `   根据名称或位置加载.class字节码
>- `definclass():  ` 把字节码转化为Class
>
>这里面需要展开讲一下`loadClass`和`findClass`，我们前面说过，当我们想要自定义一个类加载器的时候，并且像破坏双亲委派原则时，我们会重写`loadClass`方法。
>
>但是：如果我们想定义一个类加载器，但是不想破坏双亲委派模型的时候呢？
>
>这时候，就可以继承`ClassLoader`，并且重写`findClass`方法。`findClass()`方法是JDK1.2之后的`ClassLoader`新添加的一个方法。
>
>**所以，如果你想定义一个自己的类加载器，并且要遵守双亲委派模型，那么可以继承ClassLoader，并且在findClass中实现你自己的加载逻辑即可。**
>
>-----------
>
>-------------
>
>破坏双亲委派模型：
>
>- 自定义类加载器，重写其中的`loadclass`方法，使其步进行双亲委派即可。
>
>- 是JNDI、JDBC等需要加载SPI接口实现类的情况。
>
>- 是为了实现热插拔热部署工具。为了让代码动态生效而无需重启，实现方式时把模块连同类加载器一起换掉就实现了代码的热替换。
>
>- tomcat等web容器的出现
>- 第五种时OSGI、Jigsaw等模块化技术的应用
>
>-------------
>
>##### 为什么JNDI，JDBC等需要破坏双亲委派？
>
>我们日常开发中，大多数时候会通过API的方式调用Java提供的那些基础类，这些基础类时被`Bootstrap`加载的。
>
>但是，调用方式除了`API`之外，还有一种`SPI(服务提供者接口)`的方式。
>
>如典型的`JDBC`服务，我们通常通过以下方式创建数据库连接：
>
>```java
>Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/mysql", "root", "1234");
>```
>
>在以上代码执行之前，`DriverManager`会先被类加载器加载，因为`java.sql.DriverManager`类是位于`rt.jar`下面的 ，所以他会被根加载器加载。
>
>类加载时，会执行该类的静态方法。其中有一段关键的代码是：
>
>```java
>ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class);
>```
>
>这段代码，会尝试加载`classpath`下面的所有实现了`Driver`接口的实现类。
>
>那么，问题就来了。
>
>**DriverManager是被根加载器加载的，那么在加载时遇到以上代码，会尝试加载所有Driver的实现类，但是这些实现类基本都是第三方提供的，根据双亲委派原则，第三方的类不能被根加载器加载。**
>
><img src="C:\Users\whig\AppData\Roaming\Typora\typora-user-images\image-20210525213723423.png" alt="image-20210525213723423" style="zoom:80%;" />
>
>那么，怎么解决这个问题呢？
>
>于是，就**在JDBC中通过引入ThreadContextClassLoader（线程上下文加载器，默认情况下是AppClassLoader）的方式破坏了双亲委派原则。**
>
>我们深入到`ServiceLoader.load`方法就可以看到：
>
>```java
>public static <S> ServiceLoader<S> load(Class<S> service) {
>  ClassLoader cl = Thread.currentThread().getContextClassLoader();
>  return ServiceLoader.load(service, cl);
>}
>```
>
>第一行，获取当前线程的线程上下⽂类加载器` AppClassLoader`，⽤于加载 `classpath `中的具体实现类。
>
>---------
>
>----------
>
>##### 为什么Tomcat要破坏双亲委派
>
>我们知道，`Tomcat`是`web`容器，那么一个`web`容器可能需要部署多个应用程序。不同的应用程序可能会依赖同一个第三方类库的不同版本，但是不同版本的类库中某一个类的全路径名可能是一样的。如多个应用都要依赖`hollis.jar`但是`A`应用需要依赖`1.0.0`版本，但是`B`应用需要依赖`1.0.1`版本。这两个版本中都有一个类是`com.hollis.Test.class。`
>
>**如果采用默认的双亲委派类加载机制，那么是无法加载多个相同的类。**
>
>所以`Tomcat`破坏双亲委派原则，提供隔离的机制，为每个`web`容器单独提供一个`WebAppClassLoader`加载器。`Tomcat`的类加载机制：为了实现隔离性，优先加载` Web `应用自己定义的类，所以没有遵照双亲委派的约定，每一个应用自己的类加载器——`WebAppClassLoader`负责加载本身的目录下的`class`文件，加载不到时再交给`CommonClassLoader`加载，这和双亲委派刚好相反。



## 父子加载器之间的关系是继承吗？

>多人看到父加载器、子加载器这样的名字，就会认为Java中的类加载器之间存在着继承关系。
>
>甚至网上很多文章也会有类似的错误观点。
>
>这里需要明确一下，**双亲委派模型中，类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码的。**



## 如何判断两个`class`对象是否是同一个类?

>1. 类得完整类名必须一致，包括包名。
>2. 加载这个类得`classLoader`（指`classLoader`实例对象）必须相同
>
>换句话说，即使是两个类对象（class对象）来源于一个`class`文件，被同一个虚拟机加载，但是只要加载他们的`classLoader`实例不同，那么这两个类对象也是不相等的。



# ==-------------------------------------------------------------------运行时数据区==

# 各个区域概念

>![img](https://img2020.cnblogs.com/i-beta/1383365/202003/1383365-20200310164642520-698073513.png)
>
>- 说一下`jvm`区域模型 ？ 分几个区？ 每个区的作用是什么
>
>1. 程序计数器：记录吓一跳字节码指令，实现分支循环跳转，异常处理，线程恢复等功能。
>2. 虚拟机栈：存储局部变量表、操作数栈、动态链接、方法返回等信息
>3. 本地方法栈：本地方法调用
>4. 堆：线程共享，几乎所有对象都分配在堆内存当中
>5. 方法区：用于存储已被虚拟机加载的类信息、常量、静态变量



>- 程序计数器：当前线程执行的字节码的行号指示器，线程私有
>- JAVA虚拟机栈：Java方法执行的内存模型，每个Java方法的执行对应着一个栈帧的进栈和出栈的操作。
>- 本地方法栈：类似“ JAVA虚拟机栈 ”，但是为native方法的运行提供内存环境。
>- JAVA堆：对象内存分配的地方，内存垃圾回收的主要区域，所有线程共享。可分为新生代，老生代。
>- 方法区：用于存储已经被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。Hotspot中的“永久代”。
>- 运行时常量池：方法区的一部分，存储常量信息，如各种字面量、符号引用等。
>- 直接内存：并不是JVM运行时数据区的一部分， 可直接访问的内存， 比如NIO会用到这部分。
>
>按照JVM规范，除了程序计数器不会抛出OOM外，其他各个内存区域都可能会抛出OOM。
>
>堆区： 一直创建对象。 或者对象的内存超出堆申请的空间内存。 
>
>虚拟机栈和本地方法栈溢出： 在单线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配时，抛出的都是StackOverflowError异常。
>
>方法区和运行时常量池溢出： 例如创建字符串对象过多
>
>直接内存： 堆外内存 抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配，于是手动抛出异常，真正申请分配内存的方法是unsafe.allocateMemory()



 

## 程序计数器

>1. 程序计数器占用的内存空间很小，由于`Java`虚拟机的多线程是通过线程轮流切换，就会涉及到一些线程调度问题，并分配处理器执行时间的方式来实现的，在任意时刻，一个处理器只会执行一条线程中的指令。因此，为了线程切换后能够恢复到正确的执行位置，每条线程需要有一个独立的程序计数器
>2. 如果线程正在执行`Java`方法，则计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是`Native`方法，则这个计数器为空。
>3. 这个内存区域是唯一一个在虚拟机中没有规定任何`OutOfMemoryError`情况的区域。也不存在`OOM`
>
>----------
>
>------------
>
>- 为什么使用`PC`就寄存器来记录当前线程的执行地址  或者   使用`PC`寄存器存储字节码指令地址有社么用？
>
>因为`cpu`需要不停的切换线程，切换回来以后就得知道重哪开始运行，`jvm`的字节码解释器就是需要通过`pc`寄存器的值来明确下一条来执行什么样的字节码指令。
>
>----------
>
>-----------
>
>- `pc`寄存器为什么被设定为线程私有
>
>多线程在一个特定的时间只会执行其中的某一个线程的方法，`cpu`会不停的做任务切换，这样必然导致经常中断或者恢复，如何保证毫无分差呢？
>
>为了能够准确的记录各个线程正在执行的当前字节码指令地址，最好的办法就是为每一个线程都分配一个`pc`寄存器，这样各个线程之间可以相互独立计算，从而不会出现相互干扰的情况。



## 虚拟机栈

>`java`虚拟机栈介绍：主管`java`程序的运行，保存方法的局部变量、部分结果，并参与方法的调用和返回。
>
>1. `java`虚拟机栈，早起也叫`Java`栈，每个线程创建时都会创建一个虚拟机栈，内部保存一个个栈帧，对应着一次次的`Java`方法调用  就对应着栈帧的入栈和出栈。
>2. 是线程私有的。 跟线程生命周期是一样的。
>3. 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。
>4. 对于栈来说，不存在垃圾回收机制，但是会存在`OOM`栈内存溢出 递归调用。
>
>--------------
>
>##### 栈帧
>
>栈帧(`Stack Frame`)是用于支持虚拟机进行方法调用和方法执行的数据结构。栈帧存储了方法的 局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用至执行完成的过程，都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程。栈帧是线程本地的私有数据，不可能在一个栈帧中引用另外一个线程的栈帧。
>
>- **局部变量表**
>
>1. 定义为一个数字数组，主要用于存储方法参数，定义在方法体内部的局部变量，数据类型包括各类基本数据类型，对象引用，以及`return address`类
>2. 局部变量表建立在线程的栈上，是线程私有的，因此不存在数据安全问题
>3. 局部变量表容量个数，容量大小（反编译查看`locals`的值）是在编译期确定下来的
>4. 局部变量表，最基本的存储单元是`slot`槽  32位和返回类型只占用一个`slot`  `long double`占用两个`slot`
>5. 部变量表中的变量只有在当前方法调用中有效，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程
>6. 方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁
>
>========================================================================================================================
>
>- **操作数栈**
>
>1. 在方法执行的过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈/出栈
>2. 当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的
>3. 每一个操作数栈会拥有一个明确的栈深度，用于存储数值，最大深度在编译期就定义好
>4. 栈中，`32bit`类型占用一个栈单位深度，`64bit`类型占用两个栈单位深度
>5. 如果被调用方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新程序计数器中下一条需要执行的字节码指令
>6. `Java`虚拟机的解释引擎是基于栈的执行引擎，其中栈就是操作数栈
>
>案例分析一波 ` i++和 ++i` 区别
>
>`i++`：先将` i` 的值加载到操作数栈，再将` i `的值加` 1    `
>
>`++i`：先将` i `的值加 `1`，在将` i `的值加载到操作数栈
>
>---------------
>
>------------
>
>- **动态连接和方法返回地址、符加信息**
>
>动态连接：例如描述一个方法调用了其他方法时，就是通过常量池当中指向方法的符号来表示的，那么动态链接的作用就是将这些符号引用转化为调用方法的直接引用。每一个栈帧中都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个是为了方法调用过程中的动态连接。在每一个class文件中都会包含一个常量池，这个常量池中有大量的符号引用（通过符号无歧义的指向一个目标），这些符号引用一部分会在类加载阶段转换为直接引用（直接指向目标的指针，相对偏移量或者是可以定位到目标的句柄）即静态解析，另一部分在运行期转换为直接引用即动态连接。
>
>方法返回地址：在方法调用结束后，必须返回到该方法最初被调用时的位置，程序才能继续运行，所以在栈帧中要保存一些信息，用来帮助恢复它的上层主调方法的执行状态。方法返回地址就可以是主调方法在调用该方法的指令的下一条指令的地址。
>
>========================================================================================================================
>
>操作数栈的每一个元素可以是任意Java数据类型，32位的数据类型占一个栈容量，64位的数据类型占2个栈容量,且在方法执行的任意时刻，操作数栈的深度都不会超过max_stacks中设置的最大值。
>
>当一个方法刚刚开始执行时，其操作数栈是空的，随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。一个完整的方法执行期间往往包含多个这样出栈/入栈的过程。
>
>- 栈中存储的是什么
>
>1. 每个线程都有自己的栈，栈中的数据以栈帧格式存储 。线程上正在执行的每个方法都各自对应一个栈帧，栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各个数据信息
>2. 一条活动的线程中，一个时间点上，只会有一个活动的栈帧。只有当前正在执行的方法的栈顶栈帧是有效的，这个称为当前栈帧，对应方法是当前方法，对应类是当前类
>3. 不同线程中包含的栈帧不允许存在相互引用。
>4. Java方法有两种返回方式：一种是正常的函数返回，使用return指令，另外一种是抛出异常，不管哪种方式，都会导致栈帧被弹出



## 虚拟机栈面试题

>- **举出栈溢出得情况**
>
>首先`Java`虚拟机栈的大小是可以动态或者是固定不变的。
>
>1. 如果是固定的栈内存大小：线程请求的栈容量超过固定值，则`StackOverflowError` 则会出现栈溢出错误  可通过`-Xss`设置栈的大小。
>2. 如果是动态扩展：               动态扩容 无法申请到足够内存会报出`OOM`
>
>----------
>
>- **调整栈大小，就能保证不溢出么**
>
>​       不能：如果本身就是死循环递归 指定就是会报出栈内存溢出
>
>---------
>
>- **分配的栈内存是越大越好么**
>
>​       内存空间就这么大，对于栈自己来说当然是越大越好 但是对于整个内存空间不是  因为内存是有限的。
>
>--------
>
>- **垃圾回收是否会涉及到虚拟机栈**
>
>存在`error`错误  但是不存在垃圾回收机制  垃圾回收机制指在方法区和堆当中
>
>--------
>
>
>
>- **方法中定义的局部变量是否线程安全**
>
>​        局部变量如果定义在方法内部 并且不返回该变量： 线程安全
>
>​		局部变量如果定义在方法内部 并且有 返回线程不安全对应的变量： 线程不安全		逃逸分析  `StringBuilder`   	如果返回`String`线程安全
>
>​		作为参数传递 ：线程不安全



## 本地方法栈

>一个`Native Method`就是一个`Java`调用非`Java`代码的接囗，本地接口的作用是融合不同的编程语言为`Java`所用，它的初衷是融合`C/C++`程序。
>
>为什么要使用本地方法呢 ?   三个层次
>
>**与`Java`环境的交互**
>
>有时`Java`应用**需要与`Java`外面的环境交互**，这是本地方法存在的主要原因。你可以想想`Java`需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。
>
>-----
>
>**与操作系统的交互**
>
>`JVM`支持着`Java`语言本身和运行时库，它是`Java`程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以**用`Java`实现了`jre`的与底层系统的交互，甚至`JVM`的一些部分就是用`C`写的**。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。
>
>---------
>
>**`Sun's Java`**
>
>**`Sun`的解释器是用`C`实现的，这使得它能像一些普通的`C`一样与外部交互**。`jre`大部分是用`Java`实现的，它也通过一些本地方法与外界交互。例如：类`java.lang.Thread`的`setpriority()`方法是用`Java`实现的，但是它实现调用的是该类里的本地方法`setpriority()`。这个本地方法是用`C`实现的，并被植入`JVM`内部
>
>---------------
>
>**总结**：
>
>1. `java`虚拟机栈是管理`java`方法的调用。而本地方法栈是管理本地方法的调用。
>2. `java`虚拟机栈和本地方法栈 都是线程私有的
>3. `java`虚拟机栈和本地方法栈允许实现固定或者动态扩展内存大小。在内存溢出方面是相同的
>4. 例如执行`Thread.start()`方法 `start()`方法调用`start0()`方法. `start0`方法就会被压入本地方法栈当中。



## 堆

>一个`jvm`中多个线程共享运行时数据区的堆和方法区  每个线程各自拥有程序计数器 `java`虚拟机栈 本地方法栈
>
>- 堆核心概述
>
>1. `java`堆区在`jvm`启动的时候被创建，其空间大小也就确定了，但是可以动态调节申请。
>2. 堆可以处于物理上不连续空间 ，但是在逻辑上就是必须连续。
>3. 所有线程共享`java`堆





# 运行数据区面试

## 堆和栈的区别？

>栈是运行时候的单位，而堆是存储的单位： 栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。 堆 解决的是数据存储问题，即数据怎么放，放在哪



## 哪些区域会出现OOM

>- 程序计数器：当前线程执行的字节码的行号指示器，线程私有
>- JAVA虚拟机栈：Java方法执行的内存模型，每个Java方法的执行对应着一个栈帧的进栈和出栈的操作。
>- 本地方法栈：类似“ JAVA虚拟机栈 ”，但是为native方法的运行提供内存环境。
>- JAVA堆：对象内存分配的地方，内存垃圾回收的主要区域，所有线程共享。可分为新生代，老生代。
>- 方法区：用于存储已经被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。Hotspot中的“永久代”。
>- 运行时常量池：方法区的一部分，存储常量信息，如各种字面量、符号引用等。
>- 直接内存：并不是JVM运行时数据区的一部分， 可直接访问的内存， 比如NIO会用到这部分。
>
>==除了程序计数器不会抛出OOM外，其他各个内存区域都可能会抛出OOM。==



# ==----------------------------------------------------------------------------------GC==

# 垃圾判断算法



## 引用计数算法

>在这种算法中，假设堆中每个对象（不是引用）都有一个引用计数器。当一个对象被创建并且初始化赋值后，该对象的计数器的值就设置为 1，每当有一个地方引用它时，计数器的值就加 1，例如将对象 b 赋值给对象 a，那么 b 被引用，则将 b 引用对象的计数器累加 1。
>
>反之，当引用失效时，例如一个对象的某个引用超过了生命周期（出作用域后）或者被设置为一个新值时，则之前被引用的对象的计数器的值就减 1。而那些引用计数为 0 的对象，就可以称之为垃圾，可以被收集。
>
>特别地，当一个对象被当做垃圾收集时，它引用的任何对象的计数器的值都减 1。
>
>- **优点**：引用计数法实现起来比较简单，对程序不被长时间打断的实时环境比较有利。
>- **缺点**：**需要额外的空间来存储计数器，难以检测出对象之间的循环引用**。无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0。

## 可达性分析算法

>这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的
>
>**而且解决了对象之间对象间循环引用问题。G**C Root在对象图之外，是特别定义的“起点”，不可能被对象图内的对象所引用。
>
>`jvm`使用的是可达性分析算法
>
>----
>
>### GC root都有哪些
>
>1. 虚拟机栈中引用的对象、  	       比如各个线程被调用的方法中使用到的参数、局部变量。
>2. 方法区类静态属性引用的对象、 比如 Java类的引用类型静态变量。
>3. 方法区常量池引用的对象、        字符串常量池中的应用
>4. 本地方法栈JNI引用的对象        
>5. 被所有同步锁`synchronized` 持有的对象。
>
>**小技巧：** 由于root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那么他就是一个`root`; 例如类的成员变量不可以作为`GCroot` 因为这里边存放在堆里 随着对象的销毁而销毁
>
>----
>
>### 为什么类的成员变量不可以作为GCRoot
>
>1. 变量属于类变量（静态变量），那么永远不会被回收，原因是方法区中的类静态属性引用的对象是GC Roots，不会被回收。
>2. 变量属于实例（成员变量，包括final），则实例被回收才会被顺便回收（和实例一起存在堆中，栈帧中的局部变量区（GC Root）中不再引用，就回收）
>3. 变量属于实例的方法（局部变量），那么他是在栈中临时的（栈帧中的局部变量区（GC Root），GC的区域在堆和方法区，而不在栈），随着方法结束了，栈自动释放了，无需回收。
>
>-----
>
>### 不可达的对象一定会被回收么
>
>判断是否被回收，只要需要经历两次标记过程：
>
>1. 如果对象 没有GC root引用链， 则进行第一次标记。
>2. 进行筛选，判断此对象有没有必要执行finalize()方法
>
>​        1）如果对象没有重写`finalize`方法，或者`finalize`方法已经被虚拟机调用过，则虚拟机认为没有必要执行，OBJ被判定为不可触及的。
>
>​		2）如果对象重写了`finalize`方法，且还未执行过，那么对象会被插入到`F-queue`队列中，由一个虚拟机自动创建
>
>​		3) `finalize`方法是对象跳脱死亡的最后机会，GC会对`F-queue`队列中的对象进行第二次标记，如果对象与引用链上的任何一个对象建立了联系，那么在第二次标记时，对象会重队列当中移除。之后，对象再次出现没有引用存在的情况，在这个情况下，`finalized`方法不会呗再次调用，对象会直接变成不可触及的状态。也就是说，一个对象的`finalized`方法只会被调用一次。



## 4种引用 强、弱、软、虚

>- **强引用(StrongReference)**
>
>强引用不会被GC回收，例如Object  obj=new Object()    这里的obj引用便是一个强引用，不会被GC垃圾回收。
>
>- **软引用(SoftReference)**
>
>被软引用的对象，如果内存空间足够，垃圾回收期是不会回收他的，如果内存空间不足，垃圾回收期就回收这些对象占用的内存空间。软引用对象的是
>
>ava.lang.ref.SoftReference类，一个对象如果需要软引用，只需将其参数传入构造SoftReference类的构造函数当中就即可.
>
>**软引用在JVM报告内存不足的时候才会被GC回收，否则不回收，正是由于这种特性，软引用在caching中用处广泛**
>
>- **弱引用 WeakReference**
>
>弱引用用来描述那些非必须对象，比软引用的强度还更弱一些，当垃圾回收器开始工作时候，无论当前内存是否足够，都会回收有关弱引用的对象
>
>- **虚引用**
>
>**虚引用唯一目的：为了能在这个对象被收集器回收的时候收到系统通知被**
>
>1. 例如：**DirectByteBuffer**   直接内存也称为堆外内存 例如NIO提供了一种直接内存管理 ，  jvm堆上要管理操作系统的内存，这时候就不用重操作系内存中拷贝一边到jvm 堆上  称之为**ZeroCopy**      heap堆上会有一个对象来代表那块直接内存。
>
>2. **jdk1.4 NIO类，引入了一种基于通道(Channel)与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过在java堆里边存储一个DirectByteBuffer对象作为这块内存的引用进行操作，当回收时：在垃圾回收器里边有一个垃圾线程专门监听堆外内存的对象，在DirectByteBuffer上加一个虚引用，当这个对象不需要时进行回收的时候，通过虚引用，将这个对象的某一个信息会加入到队列当中，垃圾回收监听这个队列，如果存在信息，就说明某一个DirectByteBuffer对象就被回收了，然后清理堆外内存  。  假如这里DirectByteBuffer直接交给jvm垃圾回收器管理  直接内存和跟外部不存在虚引用 当垃圾回收的时候就会发生内存泄漏 **
>
>3. 所以虚引用就是关键目的就是为了清理堆外内存 DirectByteBuffer  管理堆外内存





# 垃圾回收算法



## 标记-清除算法（Mark-Sweep）

>标记-清除算法分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。
>
>标记-清除算法采用从根集合（GC Roots）进行扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收。标记-清除算法不需要进行对象的移动，只需对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。
>
>缺点：一个比较严重的问题就是容易产生内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。 

## 复制算法(Copying)

>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。 根集合（GC Roots）中扫描活动对象
>
>缺点： 对内存消耗较大



## 标记-整理算法(Mark-compact)

>**该算法标记阶段和Mark-Sweep标记清除一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动(是完成标记之后，先不清理，先移动再清理回收对象)，然后清理掉端边界以外的内存**  并更新对应的指针**。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动**，因此成本更高，但是却解决了内存碎片的问题



## 分代收集算法 **Generational Collection**

>分代收集算法是目前大部分`JVM`的垃圾收集器采用的算法。
>
>1. 它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。
>2. 老年代的特点是每次垃圾收集时只有少量对象需要被回收，区域较大，对象生命周期较长。而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，对象生命周期短、存活率低。那么就可以根据不同代的特点采取最适合的收集算法。 **新生代和老年代默认比是1：2**
>
>---
>
>新生代：  目前大部分垃圾收集器对于**新生代都采取复制Copying算法**，因为新生代中每次垃圾回收都要回收大部分对象，也就是说需要复制的操作次数较少**，但是实际中并不是按照1：1的比例来划分新生代的空间的，一般来说是将新生代划分为一块较大的Eden空间和两块较小的Survivor空间（一般为8:1:1），每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间**。
>
>老年代：  而由于**老年代的特点是每次回收都只回收少量对象，一般使用的是标记整理、和标记清除混合实现**
>
>永久代： 于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代也称方法区，具体的回收可参见上文2.5节。
>
>​    方法区存储内容是否需要回收的判断可就不一样咯。方法区主要回收的内容有：废弃常量和无用的类。对于废弃常量也可通过引用的可达性来判断，但是对于无用的类则需要同时满足下面3个条件：
>
>- 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；
>- 加载该类的`ClassLoader`已经被回收；
>- 该类对应的`java.lang.Class`对象没有在任何地方被引用，**无法在任何地方通过反射访问该类的方法。**



# GC 面试

## Java中会出现内存泄露吗？什么情况出现

>内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。
>虽然java中有垃圾回收机制，它能够将不再被使用的对象，自动从内存中清除。即使这样，java中也存在着内存泄漏的情况：
>
>1. 当长生命周期的对象持有短生命周期的对象的引用，就很可能发生内存泄漏。尽管短生命周期的对象已经不再需要，但是长生命周期的对象一直持有它的引用导致其无法被回收。例如，缓存系统；加载一个对象放在缓存系统中，一直不去使用这个对象，但是它一直被缓存引用，所以不会被回收导致缓存泄漏。
>2. 各种连接
>     比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，否则是不会自动被GC 回收的。对于Resultset 和Statement 对象可以不进行显式回收，但Connection 一定要显式回收，因为Connection 在任何时候都无法自动回收，而Connection一旦回收，Resultset 和Statement 对象就会立即为NULL。但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭Resultset Statement 对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在try里面去的连接，在finally里面释放连接
>3. 特别注意一些像HashMap、ArrayList的集合对象，它们经常会引发内存泄漏。当它们被声明为static时，它们的生命周期就会和应用程序一样长。
>     如果单例对象持有外部对象的引用，那么这个外部对象将不能被jvm正常回收，导致内存泄露。





## 方法区如何判断是否需要回收

>  方法区存储内容是否需要回收的判断可就不一样咯。方法区主要回收的内容有：废弃常量和无用的类。对于废弃常量也可通过引用的可达性来判断，但是对于无用的类则需要同时满足下面3个条件：
>
>- 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；
>- 加载该类的`ClassLoader`已经被回收；
>- 该类对应的`java.lang.Class`对象没有在任何地方被引用，**无法在任何地方通过反射访问该类的方法。**
>
>关于类加载的原理，也是阿里面试的主角，面试官也问过我比如：能否自己定义String，答案是不行，因为jvm在加载类的时候会执行双亲委派，



## jvm何时处理垃圾回收

>### 堆整体
>
>
>![img](https://img2020.cnblogs.com/blog/1534147/202003/1534147-20200327123751777-1521977355.png)**GC分类：**
>
>- **Minor GC** 会清理年轻代的内存。(正常情况大部分年轻代对象朝生夕灭，基本都不存在伊甸区拷贝更不说去老年代了)
>
>- **Major GC** 是清理老年代。
>- **Full GC** 是清理整个堆空间—包括年轻代和老年代
>
>### 年轻代
>
>年轻代用来存放新近创建的对象，尺寸随堆大小的增加和减少而相应的变化，默认值是保持为堆的1/15。
>年轻代的大小可以通过-xmn设置固定大小，也可以通过-xx:newratio设置年轻代和年老代的比例。
>年轻代中存在的对象是死亡非常快的。存在朝生夕死的情况。
>所以为了提高年轻代的垃圾回收效率，又将年轻代划分为三个区域，一个eden和两个sunrvivor from。
>
>eden和survivor默认比例是8:1:1，进行垃圾回收采用的是分代复制算法。每次新生代的使用，会是eden区和一块survivor区。当我们进行垃圾回收的时候，清除正在使用的区域，将其中的存货对象，放入到另一个survivor区域，并进行整理，保证空间的连续。如果对象长时间存活，则将对象移动到老年区。存活下来的对象，他的年龄会增长1。当对象的年龄一次次存活，一次次增长，到达15的时候，这些对象就会移步到老年代。在年轻代执行gc的时候，如果老年代的连续空间小于新生代对象的总大小，就会触发一次full gc。是为了给新生代做担保，保证新生代的老年对象可以顺利的进入到老年代的内存区。
>
>### 老年代
>
>老年代中存放的对象是存活了很久的，年龄大于15的对象。在老年代触发的gc叫major gc也叫full gc。full gc会包含年轻代的gc。但老年代只要执行gc就一定是full gc。
>full gc采用的是标记-清除算法。会产生内存碎片。在执行full gc的情况下，会阻塞程序的正常运行。老年代的gc比年轻代的gc效率上慢10倍以上。对效率有很大的影响。
>
>### 永久代
>
>永久代是hotspot虚拟机，也就是我们使用的java虚拟机的特有的概念，他不属于堆内存，是方法区的一种实现，各大厂商对方法区有各自的实现。永久代存放jvm运行时，需要的类，包含java库的类和方法，在触发full gc的情况下，永久代也会被进行垃圾回收。永久代的内存溢出也就是 pergen space。
>
>### 元空间
>
>元空间是metaspace，在jdk1.8的时候，jvm移除了永久代的概念，元空间也是对java虚拟机的方法区的一种实现。元空间与永久代最大的区别在于，元空间不在虚拟机中，使用本地内存。通过配置如下参数可以更改元空间的大小。
>-XX:MetaspaceSize：初始空间的大小。达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。
>-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。
>永久代的回收会随着full gc进行移动，消耗性能。每种类型的垃圾回收都需要特殊处理元数据。将元数据剥离出来，简化了垃圾收集，提高了效率。





## 新生代和老年代的区别

>1. 所谓的新生代和老年代是针对于分代收集算法来定义的，新生代又分为Eden和Survivor两个区。加上老年代就这三个区。数据会首先分配到Eden区 当中（当然也有特殊情况，如果是大对象那么会直接放入到老年代（大对象是指需要大量连续内存空间的java对象）。），
>2. 当Eden没有足够空间的时候就会 触发jvm发起一次Minor GC。如果对象经过一次Minor GC还存活，并且又能被Survivor空间接受，那么将被移动到Survivor空 间当中。
>3. 并将其年龄设为1，对象在Survivor每熬过一次Minor GC，年龄就加1，当年龄达到一定的程度（默认为15）时，就会被晋升到老年代 中了，当然晋升老年代的年龄是可以设置的。如果老年代满了就执行：Full GC 因为不经常执行，因此采用了 Mark-Compact算法清理



## 新生代对象啥时候晋升老年代

## 怎么判断是老年代

## 什么时候会引起垃圾回收，哪些情况

# ==-----------------------------------------------------------------------垃圾收集器==

>Jvm 1.8 默认的垃圾收集器 是 `pallreal new `和 `parallel old`  关于吞吐量的



# 7大垃圾收集器概念



>![img](https://upload-images.jianshu.io/upload_images/302647-82b918726c3997b2.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/516/format/webp)

## serial 串行回收

>**新生代单线程收集器，**标记和清理都是单线程，优点是简单高效；
>
>单线程下使用`serial`还是不错的  `serial`采用复制算法、串行回收方法执行内存回收
>
>----
>
>除了新生代`serial`收集器 `serial`还提供用于老年代的垃圾回收器`serial old`收集器  采用的标记整理和串行回收方法机制执行内存回收

## ParNew 并行回收

>`ParNew`收集器则是`serial`收集器的多线程版本 
>
>**新生代的垃圾回收：** 并行方式处理内存，同时在年轻代也采用复制算法

## Parallel   吞吐量优先

>jdk 1.8 在这里就是默认 Parallel 
>
>

## CMS 低延迟 并发标记清除

>![G1 vs CMS详细对比2](https://res-static.hc-cdn.cn/fms/img/aab188589d597a4835c55b023b35573f1603788424974.jpg)
>
>1、初始标记(STW)：**标记Gc root根对象**，及新生代应用的老年代对象，并作标记。时间快；
>
>2、并发标记：**标记线程和用户线程并发执行，标记出根对象的可达路径**。从初始标记开始找出所有存活对象(耗时长)。
>
>3、重新标记(STW)：从root开始重新扫描直接，间接关联对象,以及上述时间内程序产生的新垃圾对象(远比并发标记时间短)。
>
>4、并发清除：清理垃圾对象。
>
>优点：
>
>并发收集、低停顿。
>
>缺点：
>
>1、内存碎片：由于基于标记清除，因此有内存碎片。
>
>2、cpu敏感：由于并发执行，占用一定的内存cpu，吞吐量会下降
>
>3、浮动垃圾：由于并发处理，用户线程正在使用垃圾无法收集，因此比较早(68%)就要启动收回,回收失败会导致降级为串行收集，有比较大的STW。

## G1 区域化分代式

>**回收流程**
>
>1、初始标记(STW)：标记Gc root根对象并发标记。时间快；
>
>2、根区域扫描（root region scan）：根分区扫描，所有新复制到Survivor分区的对象，都需要被扫描并标记成根，这个过程称为根分区扫描(Root Region Scanning)。
>
>**2、并发标记：标记线程和用户线程并发执行，标记出根对象的可达路径。从初始标记开始找出所有存活对象(耗时长)。**
>
>**3、重新标记(STW)：从root开始重新扫描直接，间接关联对象,以及上述时间内程序产生的新垃圾对象(远比并发标记时间短)。**
>
>4、筛选回收(清除)：筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。
>
>优点：
>
>1、可根据用户设置停顿时间，制定回收计划(但是也可能存在超出用户的停顿时间).
>
>2、无内存碎片：与CMS的“标记--清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。
>
>-----
>
>**设计原则：**
>
>1、引入分区的思路，弱化了分代的概念，回收时则以分区为单位进行回收。每个分区都可能随G1的运行在不同代之间前后切换。(1MB~32MB, 默认2048个分区)
>
>2、首先收集尽可能多的垃圾(Garbage First)，采用启发式收集算法，在老年代找出具有高收集收益的分区进行收集(cms则会在将要耗尽内存时候再回收).
>
>3、G1可以根据用户设置的暂停时间目标自动调整年轻代和总堆大小，暂停目标越短年轻代空间越小、总空间就越大。
>
>4、G1的收集都是STW的，采用了混合(mixed)收集的方式，同时收集新生代、老年代，通过限制收集范围来控制停顿时间。



# 垃圾收集器面试

## CMS 和 G1比较

>CMS收集器是一种以获取最短回收停顿时间为目标的收集器，CMS收集器是基于“”标记--清除”(Mark-Sweep)算法实现的，整个过程分为四个步骤：  
>
>​     \1. 初始标记 (Stop the World事件 CPU停顿， 很短) 初始标记仅标记一下GC Roots能直接关联到的对象，速度很快；
>
>​      \2. 并发标记 (收集垃圾跟用户线程一起执行) 初始标记和重新标记任然需要“stop the world”，并发标记过程就是进行GC Roots Tracing的过程；
>
>​      \3. 重新标记 (Stop the World事件 CPU停顿，比初始标记稍微长，远比并发标记短)修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记时间短
>
>​      \4. 并发清理 -清除算法；
>
>　　整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。 
>
>#### CMS是一款优秀的收集器，它的主要优点是：并发收集、低停顿，但他有以下3个明显的缺点：
>
>  1.CMS收集器对CPU资源非常敏感 
>
>   在并发阶段，虽然不会导致用户线程停顿，但是会因为占用了一部分线程使应用程序变慢，总吞吐量会降低，为了解决这种情况，虚拟机提供了一种“增量式并发收集器” 
>
>的CMS收集器变种， 就是在并发标记和并发清除的时候让GC线程和用户线程交替运行，尽量减少GC 线程独占资源的时间，这样整个垃圾收集的过程会变长，但是对用户程序的影响会减少。（效果不明显，不推荐） 
>
>2. CMS处理器无法处理浮动垃圾 
>
>   CMS在并发清理阶段线程还在运行， 伴随着程序的运行自然也会产生新的垃圾，这一部分垃圾产生在标记过程之后，CMS无法再当次过程中处理，所以只有等到下次gc时候在清理掉，这一部分垃圾就称作“浮动垃圾” ， 
>
>3. CMS是基于“标记--清除”算法实现的，所以在收集结束的时候会有大量的空间碎片产生。空间碎片太多的时候，将会给大对象的分配带来很大的麻烦，往往会出现老年代还有很大的空间剩余，但是无法找到足够大的连续空间来分配当前对象的，只能提前触发 full gc。
>
>----
>
>### G1
>
>**与其他GC收集器相比，G1具备如下特点：**
>
>1、并行于并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短stop-The-World停顿时间。部分其他收集器原本需要停顿[Java](http://lib.csdn.net/base/java)线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。
>
>2、分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。它能够采用不同的方式去处理新创建的对象和已经存活了一段时间，熬过多次GC的旧对象以获取更好的收集效果。
>
>3、空间整合：与CMS的“标记--清理”算法不同**，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的**。
>
>4、可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1和ＣＭＳ共同的关注点，但Ｇ１除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，



## 为什么选择G1



## CMS 的 SWT

>CMS 的 STW 情况?CMS 什么情况会触发 Full GC?方法区，元空间。 具体怎么优化解决STW问题。



# ==---------------------------------------------------------------------------jvm调优==



# Flink  jvm参数调优





# 调优手段



# 频繁发生FullGC问题排查手段



# 项目调优





# ==-------------------------------------------------------------------------------OOM==

# 内存泄漏和内存溢出OOM

>**内存泄露：**申请使用完的内存没有释放，导致虚拟机不能再次使用该内存，此时这段内存就泄露了，因为申请者不用了，而又不能被虚拟机分配给别人用。
>
>**内存溢出：**申请的内存超出了JVM能提供的内存大小，此时称之为溢出

# 哪些情况会出现OOM

>- 程序计数器：当前线程执行的字节码的行号指示器，线程私有
>- JAVA虚拟机栈：Java方法执行的内存模型，每个Java方法的执行对应着一个栈帧的进栈和出栈的操作。
>- 本地方法栈：类似“ JAVA虚拟机栈 ”，但是为native方法的运行提供内存环境。
>- JAVA堆：对象内存分配的地方，内存垃圾回收的主要区域，所有线程共享。可分为新生代，老生代。
>- 方法区：用于存储已经被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。Hotspot中的“永久代”。
>- 运行时常量池：方法区的一部分，存储常量信息，如各种字面量、符号引用等。
>- 直接内存：并不是JVM运行时数据区的一部分， 可直接访问的内存， 比如NIO会用到这部分。
>
>按照JVM规范，除了程序计数器不会抛出OOM外，其他各个内存区域都可能会抛出OOM。

# 如何解决OOM

>**1、Java heap space**
>
>当堆内存（Heap Space）没有足够空间存放新创建的对象时，就会抛出 `java.lang.OutOfMemoryError:Javaheap space` 错误（根据实际生产经验，可以对程序日志中的 OutOfMemoryError 配置关键字告警，一经发现，立即处理）。
>
>### 原因分析
>
>`Javaheap space` 错误产生的常见原因可以分为以下几类：
>
>1、请求创建一个超大对象，通常是一个大数组。
>
>2、超出预期的访问量/数据量，通常是上游系统请求流量飙升，常见于各类促销/秒杀活动，可以结合业务流量指标排查是否有尖状峰值。
>
>3、过度使用终结器（Finalizer），该对象没有立即被 GC。
>
>4、内存泄漏（Memory Leak），大量对象引用没有释放，JVM 无法对其自动回收，常见于使用了 File 等资源没有回收。
>
>### 解决方案
>
>针对大部分情况，通常只需要通过 `-Xmx` 参数调高 JVM 堆内存空间即可。如果仍然没有解决，可以参考以下情况做进一步处理：
>
>1、如果是超大对象，可以检查其合理性，比如是否一次性查询了[数据库](https://cloud.tencent.com/solution/database?from=10680)全部结果，而没有做结果数限制。
>
>2、如果是业务峰值压力，可以考虑添加机器资源，或者做限流降级。
>
>3、如果是内存泄漏，需要找到持有的对象，修改代码设计，比如关闭没有释放的连接。
>
>## 2、GC overhead limit exceeded
>
>当 Java 进程花费 98% 以上的时间执行 GC，但只恢复了不到 2% 的内存，且该动作连续重复了 5 次，就会抛出 `java.lang.OutOfMemoryError:GC overhead limit exceeded` 错误。简单地说，就是应用程序已经基本耗尽了所有可用内存， GC 也无法回收。
>
>此类问题的原因与解决方案跟 `Javaheap space` 非常类似，可以参考上文。
>
>## 3、Permgen space
>
>该错误表示永久代（Permanent Generation）已用满，通常是因为加载的 class 数目太多或体积太大。
>
>### 原因分析
>
>永久代存储对象主要包括以下几类：
>
>1、加载/缓存到内存中的 class 定义，包括类的名称，字段，方法和字节码；
>
>2、常量池；
>
>3、对象数组/类型数组所关联的 class；
>
>4、JIT 编译器优化后的 class 信息。
>
>PermGen 的使用量与加载到内存的 class 的数量/大小正相关。
>
>### 解决方案
>
>根据 Permgen space 报错的时机，可以采用不同的解决方案，如下所示：
>
>1、程序启动报错，修改 `-XX:MaxPermSize` 启动参数，调大永久代空间。
>
>2、应用重新部署时报错，很可能是没有应用没有重启，导致加载了多份 class 信息，只需重启 JVM 即可解决。
>
>3、运行时报错，应用程序可能会动态创建大量 class，而这些 class 的生命周期很短暂，但是 JVM 默认不会卸载 class，可以设置 `-XX:+CMSClassUnloadingEnabled` 和 `-XX:+UseConcMarkSweepGC`这两个参数允许 JVM 卸载 class。
>
>如果上述方法无法解决，可以通过 jmap 命令 dump 内存对象 `jmap-dump:format=b,file=dump.hprof<process-id>` ，然后利用 Eclipse MAT https://www.eclipse.org/mat 功能逐一分析开销最大的 classloader 和重复 class。
>
>## 4、Metaspace
>
>JDK 1.8 使用 Metaspace 替换了永久代（Permanent Generation），该错误表示 Metaspace 已被用满，通常是因为加载的 class 数目太多或体积太大。
>
>此类问题的原因与解决方法跟 `Permgenspace` 非常类似，可以参考上文。需要特别注意的是调整 Metaspace 空间大小的启动参数为 `-XX:MaxMetaspaceSize`。
>
>## 5、Unable to create new native thread
>
>每个 Java 线程都需要占用一定的内存空间，当 JVM 向底层操作系统请求创建一个新的 native 线程时，如果没有足够的资源分配就会报此类错误。
>
>### 原因分析
>
>JVM 向 OS 请求创建 native 线程失败，就会抛出 `Unableto createnewnativethread`，常见的原因包括以下几类：
>
>1、线程数超过操作系统最大线程数 ulimit 限制；
>
>2、线程数超过 kernel.pid_max（只能重启）；
>
>3、native 内存不足；
>
>该问题发生的常见过程主要包括以下几步：
>
>1、JVM 内部的应用程序请求创建一个新的 Java 线程；
>
>2、JVM native 方法代理了该次请求，并向操作系统请求创建一个 native 线程；
>
>3、操作系统尝试创建一个新的 native 线程，并为其分配内存；
>
>4、如果操作系统的虚拟内存已耗尽，或是受到 32 位进程的地址空间限制，操作系统就会拒绝本次 native 内存分配；
>
>5、JVM 将抛出 `java.lang.OutOfMemoryError:Unableto createnewnativethread` 错误。
>
>### 解决方案
>
>1、升级配置，为机器提供更多的内存；
>
>2、降低 Java Heap Space 大小；
>
>3、修复应用程序的线程泄漏问题；
>
>4、限制线程池大小；
>
>5、使用 -Xss 参数减少线程栈的大小；
>
>6、调高 OS 层面的线程最大数：执行 `ulimia-a` 查看最大线程数限制，使用 `ulimit-u xxx` 调整最大线程数限制。
>
>ulimit -a .... 省略部分内容 ..... max user processes (-u) 16384
>
>## 6、Out of swap space？
>
>该错误表示所有可用的虚拟内存已被耗尽。虚拟内存（Virtual Memory）由物理内存（Physical Memory）和交换空间（Swap Space）两部分组成。当运行时程序请求的虚拟内存溢出时就会报 `Outof swap space?` 错误。
>
>### 原因分析
>
>该错误出现的常见原因包括以下几类：
>
>1、地址空间不足；
>
>2、物理内存已耗光；
>
>3、应用程序的本地内存泄漏（native leak），例如不断申请本地内存，却不释放。
>
>4、执行 `jmap-histo:live<pid>` 命令，强制执行 Full GC；如果几次执行后内存明显下降，则基本确认为 Direct ByteBuffer 问题。
>
>### 解决方案
>
>根据错误原因可以采取如下解决方案：
>
>1、升级地址空间为 64 bit；
>
>2、使用 Arthas 检查是否为 Inflater/Deflater 解压缩问题，如果是，则显式调用 end 方法。
>
>3、Direct ByteBuffer 问题可以通过启动参数 `-XX:MaxDirectMemorySize` 调低阈值。
>
>4、升级服务器配置/隔离部署，避免争用。
>
>## 7、 Kill process or sacrifice child
>
>有一种内核作业（Kernel Job）名为 Out of Memory Killer，它会在可用内存极低的情况下“杀死”（kill）某些进程。OOM Killer 会对所有进程进行打分，然后将评分较低的进程“杀死”，具体的评分规则可以参考 Surviving the Linux OOM Killer。
>
>不同于其他的 OOM 错误， `Killprocessorsacrifice child` 错误不是由 JVM 层面触发的，而是由操作系统层面触发的。
>
>### 原因分析
>
>默认情况下，Linux 内核允许进程申请的内存总量大于系统可用内存，通过这种“错峰复用”的方式可以更有效的利用系统资源。
>
>然而，这种方式也会无可避免地带来一定的“超卖”风险。例如某些进程持续占用系统内存，然后导致其他进程没有可用内存。此时，系统将自动激活 OOM Killer，寻找评分低的进程，并将其“杀死”，释放内存资源。
>
>### 解决方案
>
>1、升级服务器配置/隔离部署，避免争用。
>
>2、OOM Killer 调优。
>
>## 8、Requested array size exceeds VM limit
>
>JVM 限制了数组的最大长度，该错误表示程序请求创建的数组超过最大长度限制。
>
>JVM 在为数组分配内存前，会检查要分配的数据结构在系统中是否可寻址，通常为 `Integer.MAX_VALUE-2`。
>
>此类问题比较罕见，通常需要检查代码，确认业务是否需要创建如此大的数组，是否可以拆分为多个块，分批执行。
>
>## 9、Direct buffer memory
>
>Java 允许应用程序通过 Direct ByteBuffer 直接访问堆外内存，许多高性能程序通过 Direct ByteBuffer 结合内存映射文件（Memory Mapped File）实现高速 IO。
>
>### 原因分析
>
>Direct ByteBuffer 的默认大小为 64 MB，一旦使用超出限制，就会抛出 `Directbuffer memory` 错误。
>
>### 解决方案
>
>1、Java 只能通过 ByteBuffer.allocateDirect 方法使用 Direct ByteBuffer，因此，可以通过 Arthas 等在线诊断工具拦截该方法进行排查。
>
>2、检查是否直接或间接使用了 NIO，如 netty，jetty 等。
>
>3、通过启动参数 `-XX:MaxDirectMemorySize` 调整 Direct ByteBuffer 的上限值。
>
>4、检查 JVM 参数是否有 `-XX:+DisableExplicitGC` 选项，如果有就去掉，因为该参数会使 `System.gc()` 失效。
>
>5、检查堆外内存使用代码，确认是否存在内存泄漏；或者通过反射调用 `sun.misc.Cleaner` 的 `clean()` 方法来主动释放被 Direct ByteBuffer 持有的内存空间。
>
>6、内存容量确实不足，升级配置。







# ==---------------------------------------------------------------------------------面试==



## 对象的内存结构

>- 这个就是需要jvm知识 main方法--> object指针引用到 Object对象 在堆上
>
>![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83MDE3MTQwLTgwMzc0ZTY1YzZiMjBjYmU)

- mark wold 对象哈希码 指向锁记录的指针、指向重量级锁的指针、对象分带年龄    **8个字节**  对象头加起来就是12个字节
- 类行指针： Object.class  Person.class   指针指向你属于哪一个类   **由于默认开启压缩指针 -->classPointer 4个字节  没有开启压缩就是8个**
- 实例数据： 类成员变量   int 4  long 8
- 对其：        能被8整除的



## 对象分配内存

类加载完成后，接着会在Java堆中划分一块内存分配给对象。内存分配根据Java堆是否规整，有两种方式：

- 指针碰撞：如果Java堆的内存是规整，即所有用过的内存放在一边，而空闲的的放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样便完成分配内存工作。
- 空闲列表：如果Java堆的内存不是规整的，则需要由虚拟机维护一个列表来记录那些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表记录。

选择哪种分配方式是由 Java 堆是否规整来决定的，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。

![内存分配的两种方式](https://img-blog.csdnimg.cn/20200103213812259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)

## 为什么会有栈内存 和 堆内存之分

![img](http://uploadfiles.nowcoder.com/images/20160323/988744_1458727239702_E50CEF323E6A64E1CDDD15F4F0E75387)



## 字符串常量池、运行常量池、Class常量池

>class常量池 ：加载到内存中 原来在硬盘上 
>我们写的每一个Java类被编译后，就会形成一份class文件；class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译器生成的各种 字面量 (Literal)和 符号引用 (Symbolic References)，虚拟机要根据这个常量池表找到要执行的类名方法名，参数类型。每个class文件都有一个class常量池。
>
>----------------------------------------------------------------------------------------------------
>
>运行时常量池(Runtime Constant Pool)： 在方法区：  常量池表在类加载后存放到方法区的运行常量池中   JDK1.6常量池包含字符串常量池
>
>运行时常量池存在于内存中，也就是class常量池被加载到内存之后的版本，不同之处是：它的字面量可以动态的添加(String#intern()),符号引用可以被解析为直接引用
>JVM在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个。在解析阶段，会把符号引用替换为直接引用，解析的过程会去查询字符串常量池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与字符串常量池中是一致的。运行时常量池也是每个类都有一个
>
>-----------------------------------------------------------------------------------------------------
>
>字符串常量池  JDK6.0方法区       JDK7.0 堆中   
>
>1.在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个Hash表，默认值大小长度是1009；这个StringTable在每个HotSpot VM的实例只有一    份，被所有的类共享。字符串常量由一个一个字符组成，放在了StringTable上。
>2.在JDK6.0中，StringTable的长度是固定的，长度就是1009，因此如果放入String Pool中的String非常多，就会造成hash冲突，导致链表过长，当调String#intern()时会需要到链表上一个一个找，从而导致性能大幅度下降；
>在JDK7.0中，StringTable的长度可以通过参数指定：
>-XX:StringTableSize=66666
>
>   String s1 = "古时的风筝";
>   String s2 = "古时的风筝";
>   String a = "古时的";
>
>   String s3 = new String(a + "风筝");
>   String s4 = new String(a + "风筝");
>   System.out.println(s1 == s2); // 【1】 true
>   System.out.println(s2 == s3); // 【2】 false
>   System.out.println(s3 == s4); // 【3】 false
>   s3.intern();
>   System.out.println(s2 == s3); // 【4】 false
>   s3 = s3.intern();
>   System.out.println(s2 == s3); // 【5】 true
>   s4 = s4.intern();
>   System.out.println(s3 == s4); // 【6】 true
>
>   /**
>        * 【1】：s1 == s2 返回 ture，因为都是字面量声明，全都指向字符串常量池中同一字符串。
>        *
>        * 【2】: s2 == s3 返回 false，因为 new String() 是在堆中新建对象，所以和常量池的常量不相同。
>        *
>        * 【3】: s3 == s4 返回 false，都是在堆中新建对象，所以是两个对象，肯定不相同。
>        *
>        * 【4】: s2 == s3 返回 false，前面虽然调用了 intern() ，但是没有返回，不起作用。
>        *
>        * 【5】: s2 == s3 返回 ture，前面调用了 intern() ，并且返回给了 s3 ，此时 s2、s3 都直接指向常量池的同一个字符串。
>        *
>        * 【6】: s3 == s4 返回 true，和 s3 相同，都指向了常量池同一个字符串。
>        */
>
>       String str="a";                
>       String str1="b";                
>       String str3="ab";              
>       String str4=str+str1;            // new StringBuilder.append("a").append("b").toString() 因为new了 所以返回一个堆对象
>       String str5="a"+"b";             //编译器直接优化 str5="ab"
>       System.out.println(str4==str3);  //false
>       System.out.println(str5==str3);  //true
>
>   }



## 类实例化和初始化阶段



>- **类初始化阶段:就是执行类构造器<clinit>方法的过程**
>
>```java
><clinit>方法是由编译器自动收集类中的所有类变量的赋值动作和静态代码块的语句合并产生  
><clinit> 类构造器  <init>实例构造器  
><clinit>类构造器 不需要显示调用父类构造器 java虚拟机会保证子类<clinit方法执行前，父类<clinit>方法执行完毕 第一个执行Object
><init>实例构造器  需要显示调用父类构造器
>
>虚拟机会保证一个类的类构造器<clinit>()在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的类构造器<clinit>()，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕  在同一个类加载器下，一个类型只会被初始化一次
>进行准备阶段时候，以为静态变量设置了初始0值，而在初始化阶段才会根据程序代码来初始化类静态变量
>
>
>public class var{					类变量static  在JDK1.7存在方法区  JDK1.8存在堆中的  实例变量==成员变量 类变量=静态变量
>
>	private static final int a=1;   随 Class对象分配在堆中  准备阶段就已经完成赋值
>	private static int b=2;			随 Class对象分配在堆中  类变量 --->准备阶段赋予数据类型的0值  初始化阶段才会根据代码赋值  随着类一起消失 	
>	private int c=3;				随着java对象分配在堆中  实例变量--->实例变量将在对象实例化后随着对象一起分配在java堆中    随着对象一起消失
>	public void method(){
>	   int d=4;						在栈中 随方法共存亡 必须赋值才能使用		
>	}
>
>}
>
>
>下列Java代码中的变量a、b、c分别在内存的____存储区存放。
>class A {
>   private String a = “aa”;                a:是类中的成员  在堆上
>   public boolean methodB() {
>       String b = “bb”;					   b、c都是方法中的局部变量，存放在栈区
>       final String c = “cc”;
>   }							          请问一下变量a是个字符串，为什么不是放在方法区里面？这题目问的是变量存放位置，而不是变量指向内容的存放位置。
>}
>```
>
>
>
>- **类初始化和类实例化**
>
> - **实例变量初始化**
>
> ```java
> public class InstanceVariableInitializer {
>     private int i = 1;
>     private int j = i + 1;
>     private int z;
>
>     public InstanceVariableInitializer(int var) {
>         System.out.println(i);   1
>         System.out.println(j);   5
>         this.i = var;                        // 默认值--->赋值--->代码块--->构造函数赋值
>         System.out.println(i);   8
>         System.out.println(j);   5
>         System.out.println(z);   1
>     }
>
>     {                             
>         j += 3;
>     }
>
>     {
>         z=z+1;
>     }
>
>     public static void main(String[] args) {
>         InstanceVariableInitializer instanceVariableInitializer = new InstanceVariableInitializer(8);
>     }
> }
> 我们知道，JVM在为一个对象分配完内存之后，会给每一个实例变量赋予默认值，这个时候实例变量被第一次赋值，这个赋值过程是没有办法避免的。如果我们在声明实例变量x的同时对其进行了赋值操作，那么这个时候，这个实例变量就被第二次赋值了。如果我们在实例代码块中，又对变量x做了初始化操作，那么这个时候，这个实例变量就被第三次赋值了。如果我们在构造函数中，也对变量x做了初始化操作，那么这个时候，变量x就被第四次赋值。也就是说，在Java的对象初始化过程中，一个实例变量最多可以被初始化4次。
> ```
>
>
>
>一个Java对象的创建过程往往包括 **类初始化** 和 **类实例化** 两个阶段，**父类的类构造器<clinit>() -> 子类的类构造器<clinit>() -> 父类的成员变量和实例代码块 -> 父类的构造函数(实例构造器<init>) -> 子类的成员变量和实例代码块 -> 子类的构造函数(实例构造器<init>) ** Object是类的祖宗，首先你要搞清楚类初始化和对象初始化，每个子类初始化之前先从祖宗类进行初始化来对类变量进行赋值和其他资源的处理，然后初始化对象的时候也一样，先从祖宗进行对象初始化，这一步骤是对非静态成员变量进行的初始化与赋值操作。这下应该明白了把。只有这样做继承才有意义啊
>
>**实例化一个类的对象的过程是一个典型的递归过程**，如下图所示。进一步地说，在实例化一个类的对象时，具体过程是这样的：
>
>　　在准备实例化一个类的对象前，首先准备实例化该类的父类，如果该类的父类还有父类，那么准备实例化该类的父类的父类，依次递归直到递归到Object类。此时，首先实例化Object类，再依次对以下各类进行实例化，直到完成对目标类的实例化。具体而言，在实例化每个类时，都遵循如下顺序：先依次执行实例变量初始化和实例代码块初始化，再执行构造函数初始化。也就是说，编译器会将实例变量初始化和实例代码块初始化相关代码放到类的构造函数中去，并且这些代码会被放在对超类构造函数的调用语句之后，构造函数本身的代码之前。
>
>![img](https://img-blog.csdn.net/20170518135452979?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
>
>
>
>
>
>- **初始化**这个阶段，JVM虚拟机给出了5种必须对类进行“初始化”的情况
>
>```xml
>1.用new关键字实例化对象的时候、读取或设置一个类的静态字段的时候、调用一个类的静态方法的时候；
>2.用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则要先触发其初始化；
>3.当初始化一个类的时候，如果发现其父类还没有被初始化，则要先初始化其父类；** 这句话有待研究**
>4.当虚拟机启动时，用户需要指定一个执行的主类（包含main方法的那个类），则虚拟机会优先初始化这个主类
>5.在JDK1.7以后，动态语言支持的时候，如果一个java.lang.invoke.MethodHandle实例最后的结果是要执行第1种情况的操作，则也要进行初始化。
>6.JDK1.8接口新加入的默认方法default关键字修饰的 如果接口的实现类放生了初始化，那么接口要在其初始化之前被初始化
>```
>
>
>
>
>
>- **初始化**这个阶段，JVM虚拟机给出了5种必须对类进行“初始化”的情况
>
>1. 使用new关键字实例化对象的时候、读取或设置一个类的静态字段的时候、调用一个类的静态方法的时候；
>2. 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则要先触发其初始化；
>3. 当初始化一个类的时候，如果发现其父类还没有被初始化，则要先初始化其父类；** 这句话有待研究**
>4. 当虚拟机启动时，用户需要指定一个执行的主类（包含main方法的那个类），则虚拟机会优先初始化这个主类；
>5. 在JDK1.7以后，动态语言支持的时候，如果一个java.lang.invoke.MethodHandle实例最后的结果是要执行第1种情况的操作，则也要进行初始化。
>
>
>
>- **类的卸载时机**
>
>类的卸载跟采用的垃圾收集算法有关，在CMS中有两种方法卸载不必要的类，一种是等到元空间（Metaspace）满了的时候触发FGC，另一种是使用跟CMS并发收集算法类似的方式，不过对于元空间的阈值和触发CMS并发收集的阈值是独立的。更具体的可以参考之前的文章：CMS学习笔记。在这里，我们只需要记住，JVM中一个类的卸载要满足下面这3个条件：
>
>1. 该类所有的实例对象都已被回收；
>2. 该类的类加载器对象已经被回收；
>3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
>
>
>
>- **类加载器的作用**：类的加载是需要类加载器完成的，但是类加载器在JVM中的作用可不止这些。在JVM中，一个类的唯一性是需要这个类本身和类加载一起才能确定的，每个类加载器都有一个独立的命名空间。不同的类加载器，即使是同一个类字节码文件，最后再JVM里的类对象也不是同一个
>
>1. 将类的字节码文件从JVM外部加载到内存中
>2. 确定一个类的唯一性
>3. 提供隔离特性，为中间件开发者提供便利，例如Tomcat
>
>
>
>- 直接内存
>
>```xml
>直接内存并不是虚拟机运行时数据区的一部分，也不是Java 虚拟机规范中农定义的内存区域。在JDK1.4 中新加入了NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区（Buffer）的I/O 方式，它可以使用native 函数库直接分配堆外内存，然后通脱一个存储在Java堆中的DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。
>
>本机直接内存的分配不会受到Java 堆大小的限制，受到本机总内存大小限制
>配置虚拟机参数时，不要忽略直接内存 防止出现OutOfMemoryError异常
>
>直接内存（堆外内存）与堆内存比较
>直接内存申请空间耗费更高的性能，当频繁申请到一定量时尤为明显
>直接内存IO读写的性能要优于普通的堆内存，在多次读写操作的情况下差异明显
>
>从数据流的角度，来看
>非直接内存作用链:
>本地IO –>直接内存–>非直接内存–>直接内存–>本地IO
>直接内存作用链:
>本地IO–>直接内存–>本地IO
>```





## 频繁发生FullGC问题排查手段

>如题，机器发生频繁FullGC报警，如何定位原因？
>
>一般现象为CPU飙高，RT增加，另外很可能出现OOM。当碰到这种现象时，如何定位：
>
>### Jmap
>
>打印heap的概要信息，GC使用的算法，heap（堆）的配置及JVM堆内存的使用情况.
>
>```
>jmap -heap pid
>复制代码
>```
>
>打印每个class的实例数目,内存占用,类全名信息，VM的内部类名字开头会加上前缀”*”. 如果live子参数加上后,只统计活的对象数量.
>
>```
>jmap -histo:live pid
>复制代码
>```
>
>输出jvm的heap内容到文件，live子选项是可选的，假如指定live选项,那么只输出活的对象到文件.
>
>```
>jmap -dump:live,format=b,file=myjmapfile.txt pid
>复制代码
>```
>
>finalizerinfo 打印正等候回收的对象的信息
>
>```
>jmap -finalizerinfo pid
>复制代码
>```
>
>### arthas
>
>查看当前的jvm进程堆内存状态
>
>```
>dashboard
>复制代码
>```
>
>watch系统中某个方法，某个属性的值，严重对象当前状态。
>
>```
># watch 类全路径  方法名   '属性或者方法的全路径引用'
>watch demo.MathGame primeFactors 'target.illegalArgumentCount'
># 观察方法的第一个参数值
>watch demo.MathGame primeFactors params[0]
>复制代码
>```
>
>### jmap文件分析
>
>自带的命令分析
>
>```
>jhat <heap-dump-file>
>复制代码
>```
>
>jvisuvm装入，装入时记得选hprof，有几个不同选项，apps,hprof
>
>![image-20201101232452903](https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78d1e8bdfcad473ca0d75a7d4e1f4aab~tplv-k3u1fbpfcp-zoom-1.image)
>
>### 建议
>
>- 代码中使用无界队列，如LinkedBlockingQuene一定要注意，最好设置长度限制
>- ThreadLocal用完记得remove对象





## ==java内存模型==

**Java内存模型(即Java Memory Model，简称JMM)本身是一种抽象的概念，屏蔽硬件和操作系统的内存访问差异，并不真实存在**，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。由于JVM运行程序的实体是线程，**而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行**，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成，其简要访问过程如下图

![img](https://img-blog.csdn.net/20170608221857890?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

- 主内存

  主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管该**实例对象是成员变量还是方法中的本地变量(也称局部变量)**，当然也包括了共享的类信息、常量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发现线程安全问题。

- 工作内存

  主要存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量副本拷贝)，每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关Native方法的信息。注意由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。

- ​      **对于一个实例对象中的成员方法而言，如果方法中包含本地变量是基本数据类型（boolean,byte,short,char,int,long,float,double），将直接存储在工作内存的帧栈结构中，但倘若本地变量是引用类型，那么该变量的引用会存储在工作内存的帧栈中，而对象实例将存储在主内存(共享数据区域，堆)中。但对于实例对象的成员变量，不管它是基本数据类型或者包装类型(Integer、Double等)还是引用类型，都会被存储到堆区。至于static变量以及类本身相关信息将会存储在主内存中。需要注意的是，在主内存中的实例对象可以被多线程共享，倘若两个线程同时调用了同一个对象的同一个方法，那么两条线程会将要操作的数据拷贝一份到自己的工作内存中，执行完成操作后才刷新到主内存**

![img](https://img-blog.csdn.net/20170609093435508?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

- **由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，线程与主内存中的变量操作必须通过工作内存间接完成，主要过程是将变量从主内存拷贝的每个线程各自的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，如果存在两个线程同时对一个主内存中的实例对象的变量进行操作就有可能诱发线程安全问题**

![img](https://img-blog.csdn.net/20170610150559256?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

- 原子性：

  原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。比如对于一个静态变量int x，两条线程同时对他赋值，线程A赋值为1，而线程B赋值为2，不管线程如何运行，最终x的值要么是1，要么是2，线程A和线程B间的操作是没有干扰的，这就是原子性操作，不可被中断的特点。有点要注意的是，对于32位系统的来说，long类型数据和double类型数据(对于基本数据类型，byte,short,int,float,boolean,char读写是原子操作)，它们的读写并非原子性的，也就是说如果存在两条线程同时对long类型或者double类型的数据进行读写是存在相互干扰的，因为对于32位虚拟机来说，每次原子读写是32位的，而long和double则是64位的存储单元，这样会导致一个线程在写时，操作完前32位的原子操作后，轮到B线程读取时，恰好只读取到了后32位的数据，这样可能会读取到一个既非原值又不是线程修改值的变量，它可能是“半个变量”的数值，即64位数据被两个线程分成了两次读取。但也不必太担心，因为读取到“半个变量”的情况比较少见，至少在目前的商用的虚拟机中，几乎都把64位的数据的读写操作作为原子操作来执行，因此对于这个问题不必太在意，知道这么回事即可。

  - 编译器优化的重排

    编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。

  - 指令并行的重排

    现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序 ，**通过重排序和组合来实现指令并行**

  - 内存系统的重排

    由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。



- 可见性

  理解了指令重排现象后，可见性容易了，可见性指的是当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个修改的值。对于串行程序来说，可见性是不存在的，因为我们在任何一个操作中修改了某个变量的值，后续的操作中都能读取这个变量值，并且是修改过的新值。但在多线程环境中可就不一定了，前面我们分析过，由于线程对共享变量的操作都是线程拷贝到各自的工作内存进行操作后才写回到主内存中的，这就可能存在一个线程A修改了共享变量x的值，还未写回主内存时，另外一个线程B又对主内存中同一个共享变量x进行操作，但此时A线程工作内存中共享变量x对线程B来说并不可见，这种工作内存与主内存同步延迟现象就造成了可见性问题，另外指令重排以及编译器优化也可能导致可见性问题，通过前面的分析，我们知道无论是编译器优化还是处理器优化的重排现象，在多线程环境下，确实会导致程序轮序执行的问题，从而也就导致可见性问题。

  

- 有序性

  有序性是指对于单线程的执行代码，我们总是认为代码的执行是按顺序依次执行的，这样的理解并没有毛病，毕竟对于单线程而言确实如此，但对于多线程环境，则可能出现乱序现象，因为程序编译成机器码指令后可能会出现指令重排现象，重排后的指令与原指令的顺序未必一致，要明白的是，在Java程序中，倘若在本线程内，所有操作都视为有序行为，如果是多线程环境下，一个线程中观察另外一个线程，所有操作都是无序的，前半句指的是单线程内保证串行语义执行的一致性，后半句则指指令重排现象和工作内存与主内存同步延迟现象。

  

- JMM提供的解决方案

  在理解了原子性，可见性以及有序性问题后，看看JMM是如何保证的，在Java内存模型中都提供一套解决方案供Java工程师在开发过程使用，如原子性问题，除了JVM自身提供的对基本数据类型读写操作的原子性外，对于方法级别或者代码块级别的原子性操作，可以使用synchronized关键字或者重入锁(ReentrantLock)保证程序执行的原子性，关于synchronized的详解，看博主另外一篇文章( [深入理解Java并发之synchronized实现原理](http://blog.csdn.net/javazejian/article/details/72828483))。而工作内存与主内存同步延迟现象导致的可见性问题，可以使用synchronized关键字或者volatile关键字解决，它们都可以使一个线程修改后的变量立即对其他线程可见。对于指令重排导致的可见性问题和有序性问题，则可以利用volatile关键字解决，因为volatile的另外一个作用就是禁止重排序优化，关于volatile稍后会进一步分析。除了靠sychronized和volatile关键字来保证原子性、可见性以及有序性外，JMM内部还定义一套happens-before 原则来保证多线程环境下两个操作间的原子性、可见性以及有序性。

  

- 理解JMM中的happens-before 原则

  倘若在程序开发中，仅靠sychronized和volatile关键字来保证原子性、可见性以及有序性，那么编写并发程序可能会显得十分麻烦，幸运的是，在Java内存模型中，还提供了happens-before 原则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据，happens-before 原则内容如下

  - 程序顺序原则，即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。
  - 锁规则 解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个锁)。
  - volatile规则 volatile变量的写，先发生于读，这保证了volatile变量的可见性，简单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。
  - 线程启动规则 线程的start()方法先于它的每一个动作，即如果线程A在执行线程B的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量的修改对线程B可见
  - 传递性 A先于B ，B先于C 那么A必然先于C
  - 线程终止规则 线程的所有操作先于线程的终结，Thread.join()方法的作用是等待当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，线程B对共享变量的修改将对线程A可见。
  - 线程中断规则 对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。
  - 对象终结规则 对象的构造函数执行，结束先于finalize()方法

  上述8条原则无需手动添加任何同步手段(synchronized|volatile)即可达到效果，下面我们结合前面的案例演示这8条原则如何判断线程是否安全，如下：

## 对象的内存结构

>- 这个就是需要jvm知识 main方法--> object指针引用到 Object对象 在堆上
>
>![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83MDE3MTQwLTgwMzc0ZTY1YzZiMjBjYmU)

>- mark wold 对象哈希码 指向锁记录的指针、指向重量级锁的指针、对象分带年龄    **8个字节**  对象头加起来就是12个字节
>- 类行指针： Object.class  Person.class   指针指向你属于哪一个类   **由于默认开启压缩指针 -->classPointer 4个字节  没有开启压缩就是8个**
>- 实例数据： 类成员变量   int 4  long 8
>- 对其：        能被8整除的

## 频繁发生FullGC问题排查手段

>如题，机器发生频繁FullGC报警，如何定位原因？
>
>一般现象为CPU飙高，RT增加，另外很可能出现OOM。当碰到这种现象时，如何定位：
>
>### Jmap
>
>打印heap的概要信息，GC使用的算法，heap（堆）的配置及JVM堆内存的使用情况.
>
>```
>jmap -heap pid
>复制代码
>```
>
>打印每个class的实例数目,内存占用,类全名信息，VM的内部类名字开头会加上前缀”*”. 如果live子参数加上后,只统计活的对象数量.
>
>```
>jmap -histo:live pid
>复制代码
>```
>
>输出jvm的heap内容到文件，live子选项是可选的，假如指定live选项,那么只输出活的对象到文件.
>
>```
>jmap -dump:live,format=b,file=myjmapfile.txt pid
>复制代码
>```
>
>finalizerinfo 打印正等候回收的对象的信息
>
>```
>jmap -finalizerinfo pid
>复制代码
>```
>
>### arthas
>
>查看当前的jvm进程堆内存状态
>
>```
>dashboard
>复制代码
>```
>
>watch系统中某个方法，某个属性的值，严重对象当前状态。
>
>```
># watch 类全路径  方法名   '属性或者方法的全路径引用'
>watch demo.MathGame primeFactors 'target.illegalArgumentCount'
># 观察方法的第一个参数值
>watch demo.MathGame primeFactors params[0]
>复制代码
>```
>
>### jmap文件分析
>
>自带的命令分析
>
>```
>jhat <heap-dump-file>
>复制代码
>```
>
>jvisuvm装入，装入时记得选hprof，有几个不同选项，apps,hprof
>
>![image-20201101232452903](https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78d1e8bdfcad473ca0d75a7d4e1f4aab~tplv-k3u1fbpfcp-zoom-1.image)
>
>### 建议
>
>- 代码中使用无界队列，如LinkedBlockingQuene一定要注意，最好设置长度限制
>- ThreadLocal用完记得remove对象